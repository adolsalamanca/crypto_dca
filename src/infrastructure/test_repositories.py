"""Tests for repository implementations."""

from datetime import UTC, datetime
from decimal import Decimal
from pathlib import Path

import pytest
from psycopg import ClientCursor, connect
from psycopg.sql import SQL
from psycopg_pool import ConnectionPool
from testcontainers.postgres import PostgresContainer

from src.domain.models import Order, User
from src.infrastructure.repositories import PostgresRepository


@pytest.fixture(scope="session")
def postgres_container():
    """Start a PostgreSQL container for testing."""
    with PostgresContainer("postgres:18-alpine") as postgres:
        yield postgres


@pytest.fixture(scope="session")
def database_url(postgres_container):
    """Get database connection URL."""
    # Convert SQLAlchemy-style URL to psycopg3 format
    url = postgres_container.get_connection_url()
    return url.replace("postgresql+psycopg2://", "postgresql://")


@pytest.fixture(scope="session")
def apply_migrations(database_url):
    """Apply database migrations."""
    migrations_dir = Path(__file__).parent.parent.parent / "migrations"

    # Read and execute migration file
    migration_path = migrations_dir / "20250117184813_initial_schema.up.sql"
    sql = migration_path.read_text()

    with connect(database_url, autocommit=True) as conn:
        cur = ClientCursor(conn)
        cur.execute(SQL(sql))  # type: ignore[arg-type]


@pytest.fixture
def pool(database_url, apply_migrations):
    """Create a connection pool."""
    pool = ConnectionPool(database_url, open=True)
    yield pool
    pool.close()


@pytest.fixture
def repo(pool):
    """Create a repository instance."""
    return PostgresRepository(pool)


def test_add_user(repo):
    """Test adding a user."""
    user = User(name="John")

    user_id = repo.add_user(user)

    # Verify ID was generated by database
    assert user_id is not None


def test_add_order(repo):
    """Test adding an order."""
    # First create a user
    user = User(name="Bob")
    user_id = repo.add_user(user)

    # Create an order
    order = Order(
        user_id=user_id,
        symbol="BTCEUR",
        side="BUY",
        price=Decimal("50000.00"),
        quantity=Decimal("0.001"),
        multiplier=Decimal("0.999"),
        reprices=0,
        status="PENDING",
        created_at=datetime.now(UTC),
    )

    order_id = repo.add_order(order)

    # Verify ID was generated by database
    assert order_id is not None


def test_get_last_order(repo):
    """Test getting the last order for a user/symbol/side."""
    # Create a user
    user = User(name="Charles")
    user_id = repo.add_user(user)

    # Create first order with PENDING status
    order1 = Order(
        user_id=user_id,
        symbol="BTCEUR",
        side="BUY",
        price=Decimal("49000.00"),
        quantity=Decimal("0.001"),
        multiplier=Decimal("0.999"),
        reprices=0,
        status="PENDING",
        created_at=datetime.now(UTC),
    )
    _order1_id = repo.add_order(order1)

    # Verify PENDING order is NOT tracked in last_orders
    last_order = repo.get_last_order(user_id, "BTCEUR", "BUY")
    assert last_order is None

    # Create second order with FILLED status (should become the "last" order)
    order2 = Order(
        user_id=user_id,
        symbol="BTCEUR",
        side="BUY",
        price=Decimal("51000.00"),
        quantity=Decimal("0.002"),
        multiplier=Decimal("0.998"),
        reprices=1,
        status="FILLED",
        created_at=datetime.now(UTC),
    )
    order2_id = repo.add_order(order2)

    # Get last order - should be the FILLED one
    last_order = repo.get_last_order(user_id, "BTCEUR", "BUY")

    assert last_order is not None
    assert last_order.id == order2_id  # Compare with DB-generated ID
    assert last_order.price == Decimal("51000.00")
    assert last_order.quantity == Decimal("0.002")
    assert last_order.multiplier == Decimal("0.998")
    assert last_order.reprices == 1
    assert last_order.status == "FILLED"


def test_get_last_order_different_sides(repo):
    """Test that last_order is tracked separately for BUY and SELL."""
    user = User(name="Daisy")
    user_id = repo.add_user(user)

    # Create a BUY order with FILLED status
    buy_order = Order(
        user_id=user_id,
        symbol="ETHEUR",
        side="BUY",
        price=Decimal("3000.00"),
        quantity=Decimal("0.1"),
        multiplier=Decimal("0.999"),
        reprices=0,
        status="FILLED",
        created_at=datetime.now(UTC),
    )
    buy_order_id = repo.add_order(buy_order)

    # Create a SELL order with FILLED status
    sell_order = Order(
        user_id=user_id,
        symbol="ETHEUR",
        side="SELL",
        price=Decimal("3100.00"),
        quantity=Decimal("0.1"),
        multiplier=Decimal("1.000"),
        reprices=0,
        status="FILLED",
        created_at=datetime.now(UTC),
    )
    sell_order_id = repo.add_order(sell_order)

    # Verify they're tracked separately
    last_buy = repo.get_last_order(user_id, "ETHEUR", "BUY")
    last_sell = repo.get_last_order(user_id, "ETHEUR", "SELL")

    assert last_buy is not None
    assert last_buy.id == buy_order_id  # Compare with DB-generated ID
    assert last_buy.side == "BUY"

    assert last_sell is not None
    assert last_sell.id == sell_order_id  # Compare with DB-generated ID
    assert last_sell.side == "SELL"


def test_get_last_order_not_found(repo):
    """Test getting last order when none exists."""
    user = User(name="Eve")
    user_id = repo.add_user(user)

    # Try to get a non-existent last order
    last_order = repo.get_last_order(user_id, "BTCEUR", "BUY")

    assert last_order is None


def test_only_filled_orders_tracked(repo):
    """Test that only FILLED orders are tracked in last_orders."""
    user = User(name="Frank")
    user_id = repo.add_user(user)

    # Create a PENDING order
    pending_order = Order(
        user_id=user_id,
        symbol="BTCEUR",
        side="BUY",
        price=Decimal("48000.00"),
        quantity=Decimal("0.001"),
        multiplier=Decimal("0.999"),
        reprices=0,
        status="PENDING",
        created_at=datetime.now(UTC),
    )
    repo.add_order(pending_order)

    # Verify PENDING order is NOT in last_orders
    last_order = repo.get_last_order(user_id, "BTCEUR", "BUY")
    assert last_order is None

    # Create a FILLED order
    filled_order = Order(
        user_id=user_id,
        symbol="BTCEUR",
        side="BUY",
        price=Decimal("49000.00"),
        quantity=Decimal("0.002"),
        multiplier=Decimal("0.998"),
        reprices=1,
        status="FILLED",
        created_at=datetime.now(UTC),
    )
    filled_order_id = repo.add_order(filled_order)

    # Verify FILLED order IS in last_orders
    last_order = repo.get_last_order(user_id, "BTCEUR", "BUY")
    assert last_order is not None
    assert last_order.id == filled_order_id
    assert last_order.status == "FILLED"

    # Create another PENDING order
    another_pending = Order(
        user_id=user_id,
        symbol="BTCEUR",
        side="BUY",
        price=Decimal("50000.00"),
        quantity=Decimal("0.003"),
        multiplier=Decimal("0.997"),
        reprices=0,
        status="PENDING",
        created_at=datetime.now(UTC),
    )
    repo.add_order(another_pending)

    # Verify FILLED order is STILL in last_orders (PENDING didn't overwrite it)
    last_order = repo.get_last_order(user_id, "BTCEUR", "BUY")
    assert last_order is not None
    assert last_order.id == filled_order_id
    assert last_order.price == Decimal("49000.00")


def test_last_filled_order_updated(repo):
    """Test that multiple FILLED orders correctly update last_orders."""
    user = User(name="Grace")
    user_id = repo.add_user(user)

    # Create first FILLED order
    first_filled = Order(
        user_id=user_id,
        symbol="ETHEUR",
        side="BUY",
        price=Decimal("2900.00"),
        quantity=Decimal("0.1"),
        multiplier=Decimal("0.999"),
        reprices=0,
        status="FILLED",
        created_at=datetime.now(UTC),
    )
    first_filled_id = repo.add_order(first_filled)

    # Verify first FILLED order is in last_orders
    last_order = repo.get_last_order(user_id, "ETHEUR", "BUY")
    assert last_order is not None
    assert last_order.id == first_filled_id
    assert last_order.price == Decimal("2900.00")

    # Create second FILLED order
    second_filled = Order(
        user_id=user_id,
        symbol="ETHEUR",
        side="BUY",
        price=Decimal("3100.00"),
        quantity=Decimal("0.2"),
        multiplier=Decimal("0.998"),
        reprices=2,
        status="FILLED",
        created_at=datetime.now(UTC),
    )
    second_filled_id = repo.add_order(second_filled)

    # Verify second FILLED order replaced the first
    last_order = repo.get_last_order(user_id, "ETHEUR", "BUY")
    assert last_order is not None
    assert last_order.id == second_filled_id  # Should be second order now
    assert last_order.price == Decimal("3100.00")
    assert last_order.quantity == Decimal("0.2")
    assert last_order.reprices == 2
